# WebGPU API

## 概念

### WebGL
WebGL 是 OpenGL ES 2.0 图形库的 JavaScript 端口

### WebGL 有一些需要解决的基本问题

* 自 WebGL 发布以来，出现了新一代的原生 GPU API——最受欢迎的是微软的 Direct3D 12、苹果的 Metal 以及科纳斯组织的 Vulkan——它们提供了大量新特性。并没有任何计划对 OpenGL（以及 WebGL）进行更多更新，因此它将不会获得任意这些新的特性。然而，WebGPU 将在未来添加这些新特性。
* WebGL 完全基于绘制图形并将它们渲染到画布的用例。它并不能很好地处理通用 GPU（GPGPU）的计算。GPGPU 计算对于很多不同的用例显得越来越重要，例如那些基于机器学习的模型。

### 通用模型

![通用模型](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGPU_API/basic-webgpu-stack.png)

* 本机 GPU API 是操作系统（例如 macOS 上的 Metal）的一部分，是一种允许本机应用程序使用 GPU 功能的编程接口。API 指令通过驱动程序发送到 GPU（并接收响应）。一个系统可以有多个本机操作系统 API 和驱动程序可用于与 GPU 通信，尽管上述图示仅假设一个设备仅有一个本机 API/驱动器程序。
* 浏览器的 WebGPU 实现了通过本机 GPU API 与 GPU 进行通信。WebGPU 设配器在你的代码中实际上表示地是一个物理 GPU 和可利用的驱动程序。
* 逻辑设备是一种抽象，通过它，单个 web 应用程序可以以分区的方式访问 GPU 功能。逻辑设备需要提供复用的功能。因为一个物理设备的 GPU 可能同时被多个应用程序和进程使用，包括许多 web 引用程序。为了安全和逻辑上的原因，每个 web 应用程序都需要能够隔离地访问 WebGPU。

### 管线
管线（pipeline）是一个逻辑结构，其包含在你完成程序工作的可编程阶段。
WebGPU 目前能够处理两种类型的管线：
#### 渲染管线
用于渲染图形，通常渲染到 <canvas> 元素中，但它也可以在画面之外的地方渲染图形。
它有两个主要阶段：
* 顶点着色阶段：在该阶段中，顶点着色器（vertex shader）接受 GPU 输入的位置数据并使用像旋转、平移或透视等特定的效果将顶点在 3D 空间中定位。然后，这些顶点会被组装成基本的渲染图元，例如三角形等，然后通过 GPU 进行光栅化，计算出每个顶点应该覆盖在 canvas 上的哪些像素。
* 片元着色阶段：在该阶段中，片元着色器（fragment shader）计算由顶点着色器生成的基本图元所覆盖的每个像素的颜色。这些计算通常使用输入，如图像（以纹理的方式）提供表面细节以及虚拟化光源的位置和颜色。

#### 计算管线
用于通用计算。
计算管线包含单独的计算阶段，在该阶段中，计算着色器（compute shader）接受通用的数据，在指定数量的工作组之间并行处理数据，然后将结果返回到一个或者多个缓冲区。这些缓冲区可以包含任意类型的数据。

### 着色器
上面提到的着色器是通过 GPU 处理的指令集。WebGPU 着色器语言是用称为 WebGPU 着色器语言（WGSL）的低级的类 Rust 语言编写的。

#### WGSL
WebGPU 着色器语言（WGSL）的低级的类 Rust 语言编写的。

#### Rust
[Rust get-started](https://www.rust-lang.org/learn/get-started)
[Rust编程为什么如此流行 - 知乎](https://zhuanlan.zhihu.com/p/634626551)
Rust是一门系统编程语言 [1] ，专注于安全 [2] ，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust在语法上和C++类似 [3] ，设计者想要在保证性能的同时提供更好的内存安全。 Rust最初是由Mozilla研究院的Graydon Hoare设计创造，然后在Dave Herman, Brendan Eich以及很多其他人的贡献下逐步完善的。 [4] Rust的设计者们通过在研发Servo网站浏览器布局引擎过程中积累的经验优化了Rust语言和Rust编译器。 [5]

创建这个新语言的目的是为了解决一个顽疾：软件的演进速度大大低于硬件的演进，软件在语言级别上无法真正利用多核计算带来的性能提升。Rust是针对多核体系提出的语言，并且吸收一些其他动态语言的重要特性，比如不需要管理内存，比如不会出现Null指针等等。 [17]

Rust致力于成为优雅解决高并发和高安全性系统问题的编程语言 [18] ，适用于大型场景，即创造维护能够保持大型系统完整的边界。这就导致了它强调安全，内存布局控制和并发的特点。标准Rust性能与标准C++性能不相上下。

## 使用

### 程序步骤

1. 创建着色器模块：在 WGSL 写你的着色器代码并将其打包到一个或者多个着色器模块。
2. 获取和配置 canvas 上下文：获取 <canvas> 元素的 webgpu 上下文并将其配置为从你的 GPU 逻辑设备接收有关渲染的图形信息。如果你的应用程序没有图形输出（例如仅使用计算管线），则此步骤是不需要的。
3. 创建包含你数据的资源：你想要通过你的管线处理的数据存储在 GPU 缓冲区或者纹理中，以供应用程序访问。
4. 创建管线：定义管线描述符，详细地描述管线，包含所需的数据结构、绑定、着色器和资源布局，然后从中创建管线。我们的基本演示仅包含单个管线，但复杂的应用程序通常会包含多个用于不同目的的管线。
5. 允许计算/渲染通道：这涉及许多子步骤：
    i. 创建一个指令编码器，它可以对一组传递给 GPU 的指令执行编码。
    ii. 创建一个通道编码器对象，该对象用于发出计算/渲染指令。
    iii. 运行指令，指定使用哪些管线、从哪个缓冲区获取数据、运行多少次绘制操作等。
    iv. 完成指令列表后，将其封装到指令缓冲区中。
    v. 通过逻辑设备的指令队列提交指令到缓冲区。

### 获取设备的访问权限

1. Navigator.gpu 属性（或 WorkerNavigator.gpu，如果你在 worker 内部使用 WebGPU 功能）为当前上下文返回 GPU 对象。
2. 通过 GPU.requestAdapter() 方法访问适配器。该方法接受一个可选的设置对象，其允许你请求一个高性能或者低功耗的适配器。如果没有可选的对象，设备将提供对默认适配器的访问，这对于大多数用途来说足够了。
3. 设备可以通过 GPUAdapter.requestDevice() (en-US) 请求。该方法接受一个可选的对象（称为描述符），该设备可以用于指定你想要逻辑设备具有的确切特性和限制。如果没有可选的对象，所提供的设备将使用合理的通用的规则，这对于大多数用途来说够了。

### 创建着色器模块























